---
标题: Mysql笔记
---
<!-- TOC -->

- [1. MySQL索引的类型](#1-mysql索引的类型)
    - [1.1. B-Tree](#11-b-tree)
    - [1.2. Hash](#12-hash)
    - [1.3. R-Tree](#13-r-tree)
    - [1.4. 全文](#14-全文)
- [2. 高性能索引的策略](#2-高性能索引的策略)
    - [2.1. 前缀索引和索引选择性](#21-前缀索引和索引选择性)
    - [2.2. 多列索引](#22-多列索引)
    - [2.3. 索引顺序](#23-索引顺序)
- [3. 锁](#3-锁)
    - [3.1. 全局锁](#31-全局锁)
    - [3.2. 表级锁](#32-表级锁)
        - [3.2.1. 表锁](#321-表锁)
        - [3.2.2. 元数据锁](#322-元数据锁)
        - [3.2.3. 如何安全的给小表加字段](#323-如何安全的给小表加字段)

<!-- /TOC -->

# 1. MySQL索引的类型

## 1.1. B-Tree
+ 索引有序，对于范围搜索，前缀搜索，等值搜索，排序有效
+ ID主键关联物理记录行
+ 索引节点记录索引的范围，只有叶节点记录物理存储的行号

## 1.2. Hash
计算hash码，分唯一键和重复键。只能是等值搜索

## 1.3. R-Tree
空间数据库，只能使用MySQL特有的函数处理的数据

## 1.4. 全文
分词，停用词，排名等

# 2. 高性能索引的策略
+ 索引列不能说表达式的一部分，也不能是函数的参数
## 2.1. 前缀索引和索引选择性
> 对于一些复杂的字符串，比如身份证号，我们可以通过计算csr32来保存hash值，提高搜索速度，另外也可以根据选择性（区分度）来选择某一部分创建索引

怎么计算合适的前缀长度
```sql
select count(*) as cnt, LEFT(colum_name, 7) as pref from city group by pref order by cnt desc;
```
我们注意到`LEFT(colum_name, 7)`的用法

还有一种评估办法是，计算完整列的选择性，查看这个列上的值的区分度. 这个值大于`0.031`基本上就可用了
```sql
select count(distinct(city))/count(*) from city
```
但是这样做有一个陷阱：数据分布很不均匀

怎么创建前缀索引？
```sql
alter table city add key(city(7))
```

前缀索引有什么问题？
> mysql 无法使用前缀索引做Order by 和group by. 也无法做覆盖扫描

## 2.2. 多列索引
并不是把多个列创建单列索引，这样并不能提高Mysql的查询性能。

+ 索引合并
5.0后引入的，可以使用多个单列索引，但是不是非常有效。这是一种Mysql优化策略（从另一方面说明了索引建立的比较糟糕）

+ 索引合并的算法变种
> 通过explain分析sql的 EXTRA 里可以看出

OR条件联合（union)
> 需要耗费大量的CPU，内存资源。（缓存，排序，合并）

AND条件相交(intersection)
> 需要一个包含所有相关列的多列索引

可以通过`optimizer_switch`来关闭索引合并功能

## 2.3. 索引顺序
兼顾查询，排序和分组的需要。索引列的顺序意味着按照最左列进行排序。选择性最高的放在最前面（经验法则，但是有时候考虑到排序和分组，这条法则也不一定有效）。

什么是选择性最高的？简单说就是过滤的数据最多的。

此SQL可以简单评估谁的区分度最高
```sql
select count(distinct(staff_id))/count(*), count(distinct(customer_id))/count(*) from payment
```

# 3. 锁
## 3.1. 全局锁
Mysql加全局锁的命令 Flush tables with read lock (FTWRL). 让数据库处于只读状态。DML，DDL命令都会阻塞。

应用场景：做全库逻辑备份，但是代价太高
+ 备份期间，其他应用不能有更新等业务操作
+ 从库备份的话，不能同步主库的binlog，导致数据落后太多。
+ 而且如果备份顺序不当，可能导致业务功能不正确。

对于InnoDB我们可以使用可重复读的事物隔离级别，因为MVCC的支持，使用MySQL官方自带的数据库备份工具`mysqldump --single-transaction`,导出数据的时候
启动一个事务，确保**一致性视图**。

但是不是所有的存储引擎都支持这个事务隔离级别，所以，`FTWRL`这个命令的存在也是有价值的。

还有一种将数据库设置为只读的办法：`set global readonly=true`, 但是一般不这样做，原因
+ 这个参数被用来其他逻辑判断（比如判断是否为主库还是从库）。
+ 异常处理上有差异。用`FTWRL`这个命令，当客户端异常断开后会释放全局锁，这个库就又可以更新了，但是设置`readonly=true`即使客户端发生异常，也一直会
保持**readonly**状态。

## 3.2. 表级锁
### 3.2.1. 表锁
语法是 `lock tables xxx read/write`然后用`unlock tables`主动释放锁。

### 3.2.2. 元数据锁
MDL锁，不需要显示使用，访问一个表的时候自动加上 目的是 `访问数据的时候，防止修改表的结构`

给表加字段，或者修改字段，或者加索引，都需要扫描全表数据，扫描全表数据会对表加锁，影响线上其他线程的正常业务逻辑查询任务。

MDL锁，只有事务提交后才释放

当一个sessionA开启事务在查询数据，sessionB准备修改表结构，sessionA还没有提交，而sessionB就会阻塞，并且sessionB后边的所有读写sessionxx都会被
阻塞，整个数据库看起来是不可用了。

### 3.2.3. 如何安全的给小表加字段
+ 首选查看`infomation_schema.innodb_trx`表有没有正在执行的长事务。如果有先暂停等待事务执行完毕，或者kill掉这个事务。
+ 使用`alter table table_name WAIT N add colum ...`的方法，尝试等待一段时间，如果没有获取到MDL锁，就主动退出，不阻塞后边的语句